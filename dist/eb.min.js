/**
 * Element Behaviors v1.0.0 Copyright (c) 2024 Caboodle Tech Inc.
 * License and source code available at: https://github.com/caboodle-tech/element-behaviors
 */
!function(){"use strict";const e=new class{#e;#t;#s;#o;#n;#a=null;#i;#r=!1;#c;#h;#d="1.0.0";constructor(){if(this.#a)return this.#a;this.#a=this,this.#e=new Map,this.#t=new WeakMap,this.#s=new Map,this.#n=new WeakMap,this.#o=new Map,this.#i=new MutationObserver(this.#l.bind(this)),this.#h=new Map,this.#c=this.#m(this.#u,50),this.#b(),this.#v(document.documentElement),this.#p()}#f(e){const t=e.getAttribute("has");if(t){this.#o.has(e)||this.#w(e);const s=t.trim().split(/\s+/),o=this.#t.get(e)||new Map,n=this.#n.get(e)||e.ownerDocument,a=e.ownerDocument;this.#n.set(e,a);for(const[t,n]of o)n.connected&&(s.includes(t)||(n.connected=!1,n.instance.disconnectedCallback&&n.instance.disconnectedCallback(e)));const i=[],r=[];for(const t of s){let{connected:s,instance:c}=o.get(t)||{};const h=this.#e.get(t);if(h){if(!c){if(c=new h(e),h.observedAttributes)for(const t of h.observedAttributes)this.#i.observe(e,{attributes:!0,attributeFilter:[t]});o.set(t,{connected:!0,instance:c})}s||n===a||i.push(c),s||r.push({behaviorName:t,instance:c})}}i.forEach((t=>{t.adoptedCallback&&t.adoptedCallback(e)})),r.forEach((t=>{t.instance.connectedCallback&&t.instance.connectedCallback(e),o.set(t.behaviorName,{connected:!0,instance:t.instance})})),this.#t.set(e,o)}else this.#E(e)}define(e,t){return!this.#e.has(e.toLowerCase())&&(this.#e.set(e.toLowerCase(),t),!0)}#E(e){const t=this.#t.get(e);if(t)for(const[s,o]of t)o.connected&&o.instance.disconnectedCallback&&o.instance.disconnectedCallback(e),o.connected=!1}getBehaviorElements(e=void 0){let t;if(e){t=[];e.trim().split(" ").forEach((e=>{t.push(new RegExp(`\\b${e}\\b`,"i"))}))}const s=[];return this.#o.forEach((o=>{const n=o.deref();if(void 0!==n){if(e){let e=0;if(t.forEach((t=>{t.test(n.getAttribute("has"))&&(e+=1)})),t.length!==e)return}s.push(n)}})),s}#l(e){for(const t of e)if("attributes"===t.type)"has"===t.attributeName&&this.#f(t.target),this.#g(t.target,t.attributeName);else if("childList"===t.type){for(const e of t.addedNodes)if(e.nodeType===Node.ELEMENT_NODE){if("IFRAME"===e.nodeName&&this.#D(e),this.#h.has(e)){const{processed:t,shadowRoot:s}=this.#h.get(e);s.querySelectorAll("*").forEach((e=>{e.nodeType===Node.ELEMENT_NODE&&this.#f(e)}))}this.#f(e)}for(const e of t.removedNodes)if(e.nodeType===Node.ELEMENT_NODE){if("IFRAME"===e.nodeName&&(this.#o.delete(element),this.#c()),this.#h.has(e)){const{processed:t,shadowRoot:s}=this.#h.get(e);s.querySelectorAll("*").forEach((e=>{e.nodeType===Node.ELEMENT_NODE&&this.#E(e)}))}this.#E(e)}}}#b(){const e=Element.prototype.attachShadow,t=e=>{this.trackShadowDocument(e)};var s;Element.prototype.attachShadow=(s=e,function(){const e=s.apply(this,arguments);return t(this),e})}#v(e,t={attributes:!0,childList:!0,subtree:!0}){this.#s.set(e,t)}#g(e,t){const s=this.#t.get(e);if(s)for(const[,o]of s){const{instance:s}=o;if(s.constructor.observedAttributes?.includes(t)){const o=s[t],n=e.getAttribute(t);s.attributeChangedCallback?.(t,o,n,e)}}}removeBehavior(e,t){const s=[];"array"===this.whatIs(e)?s.push(...e):s.push(e);const o=t.trim().split(" ");o.forEach(((e,t)=>{o[t]=e.toLowerCase()})),s.forEach((e=>{const t=this.#t.get(e);let s=e.getAttribute("has")||"";o.forEach((o=>{const n=t.get(o);s=s.replace(o,""),n.instance.disconnectedCallback&&n.instance.disconnectedCallback(e),t.delete(o)})),e.setAttribute("has",s.trim()),0===t.size&&(this.#t.delete(e),this.#n.delete(e),this.#o.delete(e))}))}#u(){this.#C(),this.#p()}setObserverTimeout(e=50){"number"===this.whatIs(e)&&(e<0&&(e=1),this.#c=this.#m(this.#u,e))}#p(){this.#r||(this.#s.forEach(((e,t)=>{this.#i.observe(t,e)})),this.#r=!0)}#C(){this.#r&&(this.#i.disconnect(),this.#r=!1)}#m(e,t){let s,o;return(...n)=>{const a=this;o?(clearTimeout(s),s=setTimeout((()=>{Date.now()-o>=t&&(e.apply(a,n),o=Date.now())}),Math.max(t-(Date.now()-o),0))):(e.apply(a,n),o=Date.now())}}#w(e){this.#o.set(e,new WeakRef(e))}#D(e){e.contentWindow?.document&&(this.#s.has(e)||(iframe.contentWindow.document.head.appendChild(document.createElement("script")).textContent="\n            /**\n             * This is the same monkey patch from Element Behaviors but modified to send iframe\n             * shadow dom behaviors to the main document for Element Behaviors to process.\n             */\n            const originalAttachShadow = Element.prototype.attachShadow;\n            const callbackTrackShadow = (element) => {\n                parent.elementBehaviors.trackShadowDocument(element);\n            };\n            Element.prototype.attachShadow = (function(originalMethod) {\n                return function() {\n                    const result = originalMethod.apply(this, arguments);\n                    callbackTrackShadow(this);\n                    return result;\n                };\n            })(originalAttachShadow);\n        ",e.contentWindow.addEventListener("DOMContentLoaded",(()=>{this.#v(e.contentDocument.documentElement),this.#c(),e.contentDocument.documentElement.querySelectorAll("*").forEach((e=>{e.nodeType===Node.ELEMENT_NODE&&this.#f(e)}))}))))}trackShadowDocument(e){const{shadowRoot:t}=e;t&&"open"!==!t.mode&&(this.#s.get(t)||(this.#h.set(e,{processed:!1,shadowRoot:t}),this.#v(t),this.#c()))}undefine(e,t){const s=this.#e.get(e.toLowerCase());if(!s)return!1;if(s!==t)return!1;const o=this.getBehaviorElements(e.toLowerCase());return this.removeBehavior(o,e),this.#e.delete(e.toLowerCase()),!0}version(){return this.#d}whatIs(e){try{return{}.toString.call(e).match(/\s([^\]]+)/)[1].toLowerCase()}catch(e){return}}};window.elementBehaviors=e}();
